单元测试的存在意义是什么
让代码拥有被重构和维护的资本

当对代码进行重构或维护时，Jest单元测试可以帮助开发人员确保重构或修改后的代码仍然符合预期行为。单元测试可以作为重构过程中的保护网，确保在重构过程中不会引入新的问题，通过运行测试用例，可以验证重构对现有功能的影响，避免引入新的问题
提前发现和修复问题
通过编写测试用例，Jest单元测试可以帮助开发人员在开发过程中及早发现和修复代码中的问题。这有助于减少后续阶段发现的错误和缺陷，节省时间和资源
提供快速反馈和确认
单元测试可以快速运行，并且只验证独立的代码单元。这使得开发人员可以快速获得关于代码是否按预期工作的反馈。当进行维护或修复时，单元测试可以帮助开发人员确认修复是否成功，避免引入新的问题。
单元测试如何让代码拥有被重构和维护的资本
假设目前有一个公共函数，它要为很多场景服务，经过漫长的迭代，具体的代码实现已经变得十分糟糕，如果让你去重构，或者让你去为该公共函数添加新的职责，你必然会压力山大，心惊肉跳，因为涉及代码的改动，总会有可能产生一些隐形的问题，对原本稳定的业务造成一定的影响，所以在这种场景下，该函数并没有重构和维护的资本，但如果我们这个时候，为该函数编写一个完美的单元测试，很多事情就会简单很多，我们只需要在重构完之后再跑一次测试用例，如果所有TestCase状态都为Pass，则说明本次重构没有改变原有的功能，如果有TestCase的状态是Fail的我们也可以快速定位问题，解决问题。

单元测试如何提前发现/修复问题
正如上述例子所讲，如果有TestCase的状态是Fail的我们就可以快速定位问题，在代码开发阶段即可解决问题，而不用等到线上环境再发现问题。

如何编写测试用例，编写测试用例的时机
日常业务代码开发最常遇到的三种场景
重零到一开发一个新功能
重构代码
基于现有功能做二次开发，如为一个现有的函数添加一个新的功能点
对应场景的编写测试用例指引
对于场景一：

      目前的做法是代码开发完成后，直接交给ai去生成覆盖率百分之八十以上的覆盖率，这样做数据虽然很漂亮，但并没有什么实际的意义，因为ai并不了解具体需求，所有它生成的单元测试也许并不能帮你检查出功能性的缺憾。

      更提倡的做法是，开发先针对本次的需求，列出详细的测试用例，再根据这些测试用例，结合代码让Ai生成对应的TestCase脚本，这样生成出来的脚本，才能真正的覆盖到我们的需求，才能为后续的重构和维护阶段保驾护航

对于场景二和场景三:

     无论是重构代码或者基于现有功能做二次开发，都有一个大前提就是要保证原有功能不受影响，因此在重构代码或者基于现有功能做二次开发的工作开展之前，我们就应该为其编写好完美的单元测试，为原有功能铺一张保护网，开发完毕后，再跑一次测试用例，检查具体的影响，然后再对为新的功能点编写对应的TestCase(这部分针对的是二次开发的场景)


如何更快更低成本的编写更好的单元测试
单元测试顾名思义针对的是单元，即一个个职责单一的零件，而不是一条整合了各种功能的流水线

所以想要更快更低成本的编写更好的单元测试，我们必须要改掉编码上的坏习惯，建议将代码参照单一职责模式划分成一个一个模块/零件，并参照最少知识原则将其组织成一条完整的Flow

然后才是针对各个单元/模块编写结合上面两点指引编写单元测试

具体例子可以查看以下链接:

how to generating unit tests via openAi

拓展，关于自动化集成测试
上述提到单元测试是针对零件的自动化测试，那么对于整合了各种零件的完整流程的测试，我们称之为集成测试，而针对集成测试运营而生的web自动化测试框架，目前比较热门的是Selenium

学习参考资料如下:
https://www.bilibili.com/video/BV1Z4411o7TA/?spm_id_from=333.337.search-card.all.click

理论上来说，自动化集成测试比单元测试更重要

当然成本也更高

